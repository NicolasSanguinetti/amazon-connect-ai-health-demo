AWSTemplateFormatVersion: '2010-09-09'
Description: 'Hotel Reservation API Gateway with DynamoDB and Lambda'

Parameters:
  SeedDataUrl:
    Type: String
    Description: 'URL to fetch hotel seed data from (JSON format)'
    Default: ''
  OpenApiSpecUrl:
    Type: String
    Description: 'URL to fetch OpenAPI specification from (YAML format)'
    Default: ''

Resources:
  # API Gateway CloudWatch Role
  ApiGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs
    DeletionPolicy: Delete

  # API Gateway Account
  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchRole.Arn

  # CloudWatch Log Group for API Gateway
  ApiLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${AWS::StackName}'
      RetentionInDays: 7
    DeletionPolicy: Delete

  # CloudWatch Log Group for Lambda Functions
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-hotel-api'
      RetentionInDays: 7
    DeletionPolicy: Delete

  # DynamoDB Tables
  MedicosTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: medicoId
          AttributeType: S
        - AttributeName: especialidad
          AttributeType: S
      KeySchema:
        - AttributeName: medicoId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: EspecialidadIndex
          KeySchema:
            - AttributeName: especialidad
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      BillingMode: PAY_PER_REQUEST
    DeletionPolicy: Delete

  TurnosTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: turnoId
          AttributeType: S
        - AttributeName: pacienteId
          AttributeType: S
      KeySchema:
        - AttributeName: turnoId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: PacienteIndex
          KeySchema:
            - AttributeName: pacienteId
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      BillingMode: PAY_PER_REQUEST
    DeletionPolicy: Delete

  # Lambda Execution Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CloudWatchLogsAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub '${LambdaLogGroup.Arn}:*'
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt MedicosTable.Arn
                  - !Sub '${MedicosTable.Arn}/index/*'
                  - !GetAtt TurnosTable.Arn
                  - !Sub '${TurnosTable.Arn}/index/*'
        - PolicyName: XRayAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                Resource: '*'
    DeletionPolicy: Delete

  # Custom Resource Lambda Role for API Key Retrieval
  ApiKeyRetrievalRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ApiGatewayAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - apigateway:GET
                Resource: !Sub 'arn:aws:apigateway:${AWS::Region}::/apikeys/*'
    DeletionPolicy: Delete

  # Custom Resource Lambda Role for Data Seeding
  DataSeedingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBSeedingAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:BatchWriteItem
                Resource:
                  - !GetAtt MedicosTable.Arn
        - PolicyName: S3ReadAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: '*'
    DeletionPolicy: Delete

  # Custom Resource Lambda Function for Data Seeding
  DataSeedingFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs22.x
      Handler: index.handler
      Role: !GetAtt DataSeedingRole.Arn
      Timeout: 300
      MemorySize: 256
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, PutCommand, BatchWriteCommand } = require('@aws-sdk/lib-dynamodb');
          const { S3Client, GetObjectCommand } = require('@aws-sdk/client-s3');

          const dynamoClient = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(dynamoClient);
          const s3Client = new S3Client({});

          // Function to fetch data from S3 URL or HTTP(S) URL
          async function fetchMedicosData(url) {
              console.log(`Fetching data from: ${url}`);
              
              // Check if it's an S3 URL (https://bucket.s3.region.amazonaws.com/key or s3://bucket/key)
              const s3HttpsMatch = url.match(/https:\/\/([^.]+)\.s3\.([^.]+)\.amazonaws\.com\/(.+)/);
              const s3UriMatch = url.match(/s3:\/\/([^\/]+)\/(.+)/);
              
              if (s3HttpsMatch) {
                  // S3 HTTPS URL format
                  const bucket = s3HttpsMatch[1];
                  const key = s3HttpsMatch[3];
                  console.log(`Detected S3 HTTPS URL - Bucket: ${bucket}, Key: ${key}`);
                  
                  const command = new GetObjectCommand({ Bucket: bucket, Key: key });
                  const response = await s3Client.send(command);
                  const bodyContents = await response.Body.transformToString();
                  return JSON.parse(bodyContents);
              } else if (s3UriMatch) {
                  // S3 URI format
                  const bucket = s3UriMatch[1];
                  const key = s3UriMatch[2];
                  console.log(`Detected S3 URI - Bucket: ${bucket}, Key: ${key}`);
                  
                  const command = new GetObjectCommand({ Bucket: bucket, Key: key });
                  const response = await s3Client.send(command);
                  const bodyContents = await response.Body.transformToString();
                  return JSON.parse(bodyContents);
              } else {
                  // Regular HTTP(S) URL - use plain HTTP client
                  console.log(`Using HTTP(S) client for URL: ${url}`);
                  const https = require('https');
                  const http = require('http');

                  return new Promise((resolve, reject) => {
                      const client = url.startsWith('https:') ? https : http;

                      client.get(url, (response) => {
                          let data = '';

                          response.on('data', (chunk) => {
                              data += chunk;
                          });

                          response.on('end', () => {
                              try {
                                  const hotels = JSON.parse(data);
                                  resolve(hotels);
                              } catch (error) {
                                  reject(new Error(`Failed to parse JSON: ${error.message}`));
                              }
                          });
                      }).on('error', (error) => {
                          reject(error);
                      });
                  });
              }
          }

          exports.handler = async (event, context) => {
              console.log('Event:', JSON.stringify(event, null, 2));

              const response = {
                  Status: 'SUCCESS',
                  Reason: 'See the details in CloudWatch Log Stream: ' + context.logStreamName,
                  PhysicalResourceId: context.logStreamName,
                  StackId: event.StackId,
                  RequestId: event.RequestId,
                  LogicalResourceId: event.LogicalResourceId,
                  Data: {}
              };

              try {
                  const tableName = event.ResourceProperties.TableName;
                  const seedDataUrl = event.ResourceProperties.SeedDataUrl;

                  if (event.RequestType === 'Delete') {
                      console.log('Delete request - no action needed for seeding');
                      await sendResponse(event, context, response);
                      return;
                  }

                  let hotels = [];

                  // Try to fetch from provided URL
                  if (seedDataUrl) {
                      console.log(`Fetching hotel data from: ${seedDataUrl}`);
                      hotels = await fetchMedicosData(seedDataUrl);
                      console.log(`Successfully loaded ${hotels.length} hotels from URL`);
                  } else {
                      // Fail if no seed data URL is provided
                      throw new Error('SeedDataUrl parameter is required for data seeding');
                  }

                  console.log(`Seeding ${hotels.length} hotels to table: ${tableName}`);

                  // Use batch write for efficiency
                  const batchSize = 25; // DynamoDB batch write limit
                  for (let i = 0; i < hotels.length; i += batchSize) {
                      const batch = hotels.slice(i, i + batchSize);

                      const putRequests = batch.map(hotel => ({
                          PutRequest: {
                              Item: hotel
                          }
                      }));

                      const params = {
                          RequestItems: {
                              [tableName]: putRequests
                          }
                      };

                      await docClient.send(new BatchWriteCommand(params));
                      console.log(`Seeded batch ${Math.floor(i/batchSize) + 1}`);
                  }

                  response.Data = {
                      Message: `Successfully seeded ${hotels.length} hotels`,
                      MedicosCount: hotels.length
                  };

                  console.log('Medicos seeding completed successfully!');

              } catch (error) {
                  console.error('Error seeding data:', error);
                  response.Status = 'FAILED';
                  response.Reason = error.message;
              }

              await sendResponse(event, context, response);
          };

          async function sendResponse(event, context, response) {
              const responseBody = JSON.stringify(response);
              console.log('Response body:', responseBody);

              const https = require('https');
              const url = require('url');

              const parsedUrl = url.parse(event.ResponseURL);
              const options = {
                  hostname: parsedUrl.hostname,
                  port: 443,
                  path: parsedUrl.path,
                  method: 'PUT',
                  headers: {
                      'content-type': '',
                      'content-length': responseBody.length
                  }
              };

              return new Promise((resolve, reject) => {
                  const request = https.request(options, (response) => {
                      console.log('Status code:', response.statusCode);
                      console.log('Status message:', response.statusMessage);
                      resolve();
                  });

                  request.on('error', (error) => {
                      console.log('send(..) failed executing https.request(..):', error);
                      reject(error);
                  });

                  request.write(responseBody);
                  request.end();
              });
          }
    DeletionPolicy: Delete

  # Custom Resource to Seed Hotel Data
  MedicosDataSeeding:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt DataSeedingFunction.Arn
      TableName: !Ref MedicosTable
      SeedDataUrl: !Ref SeedDataUrl
    DependsOn: MedicosTable

  # Custom Resource Lambda Function to Get API Key Value
  ApiKeyRetrievalFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt ApiKeyRetrievalRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse

          def handler(event, context):
              response_data = {}
              try:
                  print(f"Received event: {json.dumps(event, default=str)}")

                  if event['RequestType'] == 'Delete':
                      print("Delete request - sending success response")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return

                  api_key_id = event['ResourceProperties']['ApiKeyId']
                  print(f"Getting API key value for: {api_key_id}")

                  client = boto3.client('apigateway')
                  response = client.get_api_key(apiKey=api_key_id, includeValue=True)

                  api_key_value = response['value']
                  response_data = {'ApiKeyValue': api_key_value}

                  print(f"Successfully retrieved API key value")
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

              except Exception as e:
                  error_message = f"Error in API Key retrieval: {str(e)}"
                  print(error_message)

                  # Always send a response to prevent CloudFormation from hanging
                  try:
                      cfnresponse.send(event, context, cfnresponse.FAILED, {
                          'Error': error_message
                      })
                  except Exception as send_error:
                      print(f"Failed to send error response: {str(send_error)}")
                      # Last resort - try to send minimal response
                      try:
                          cfnresponse.send(event, context, cfnresponse.FAILED, {})
                      except:
                          print("Complete failure to send any response to CloudFormation")
    DeletionPolicy: Delete

  # Custom Resource to Get API Key Value
  ApiKeyValueRetrieval:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt ApiKeyRetrievalFunction.Arn
      ApiKeyId: !Ref TurnosApiKey
    DependsOn: TurnosApiKey

  # S3 Bucket for OpenAPI Specification
  OpenApiBucket:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
    DeletionPolicy: Delete

  # Custom Resource Lambda Role for S3 Upload
  S3UploadRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:GetObject
                  - s3:GetObjectVersion
                  - s3:ListBucket
                Resource:
                  - !Sub '${OpenApiBucket.Arn}'
                  - !Sub '${OpenApiBucket.Arn}/*'
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: '*'
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                Resource: !Ref 'AWS::StackId'
    DeletionPolicy: Delete

  # Custom Resource Lambda Function to Upload OpenAPI Spec
  S3UploadFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt S3UploadRole.Arn
      Timeout: 60
      MemorySize: 512
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import urllib.request
          import urllib.error
          import re

          def fetch_openapi_spec(url):
              """Fetch OpenAPI spec from URL (supports S3 URIs, S3 HTTPS URLs, and regular HTTP/HTTPS)"""
              print(f"Fetching OpenAPI spec from: {url}")

              # Check if it's an S3 URI (s3://bucket/key)
              s3_uri_match = re.match(r's3://([^/]+)/(.+)', url)
              if s3_uri_match:
                  bucket = s3_uri_match.group(1)
                  key = s3_uri_match.group(2)
                  print(f"Detected S3 URI - Bucket: {bucket}, Key: {key}")
                  
                  s3_client = boto3.client('s3')
                  response = s3_client.get_object(Bucket=bucket, Key=key)
                  content = response['Body'].read().decode('utf-8')
                  print(f"Successfully fetched OpenAPI spec from S3 ({len(content)} bytes)")
                  return content

              # Check if it's an S3 HTTPS URL (https://bucket.s3.region.amazonaws.com/key)
              s3_https_match = re.match(r'https://([^.]+)\.s3\.([^.]+)\.amazonaws\.com/(.+)', url)
              if s3_https_match:
                  bucket = s3_https_match.group(1)
                  key = s3_https_match.group(3)
                  print(f"Detected S3 HTTPS URL - Bucket: {bucket}, Key: {key}")
                  
                  s3_client = boto3.client('s3')
                  response = s3_client.get_object(Bucket=bucket, Key=key)
                  content = response['Body'].read().decode('utf-8')
                  print(f"Successfully fetched OpenAPI spec from S3 ({len(content)} bytes)")
                  return content

              # Regular HTTP(S) URL
              print(f"Using HTTP(S) client for URL: {url}")
              try:
                  request = urllib.request.Request(url)
                  print(f"Request headers: {request.headers}")

                  with urllib.request.urlopen(request) as response:
                      print(f"Response status: {response.status}")
                      print(f"Response headers: {dict(response.headers)}")
                      content = response.read().decode('utf-8')
                      print(f"Successfully fetched OpenAPI spec ({len(content)} bytes)")
                      return content

              except urllib.error.HTTPError as e:
                  print(f"HTTP Error {e.code}: {e.reason}")
                  print(f"Response headers: {dict(e.headers)}")
                  print(f"Response body: {e.read().decode('utf-8', errors='ignore')}")
                  raise
              except urllib.error.URLError as e:
                  print(f"URL Error: {e.reason}")
                  raise
              except Exception as e:
                  print(f"Unexpected error: {type(e).__name__}: {str(e)}")
                  raise

          def handler(event, context):
              response_data = {}
              try:
                  print(f"Received event: {json.dumps(event, default=str)}")

                  bucket_name = event['ResourceProperties']['BucketName']
                  openapi_spec_url = event['ResourceProperties'].get('OpenApiSpecUrl', '')
                  api_gateway_url = event['ResourceProperties']['ApiGatewayUrl']

                  print(f"Processing request for bucket: {bucket_name}")

                  s3 = boto3.client('s3')

                  # Only delete S3 object if the entire stack is being deleted (not during resource replacement)
                  if event['RequestType'] == 'Delete':
                      print("Delete request received - checking if this is a stack deletion or resource replacement")

                      # Check if this is a stack deletion by examining the stack status
                      try:
                          cloudformation = boto3.client('cloudformation')
                          stack_name = event['StackId'].split('/')[-2]  # Extract stack name from ARN

                          response = cloudformation.describe_stacks(StackName=stack_name)
                          stack_status = response['Stacks'][0]['StackStatus']

                          print(f"Stack status: {stack_status}")

                          # Only delete S3 object if stack is being deleted (not during updates/replacements)
                          if stack_status in ['DELETE_IN_PROGRESS']:
                              print("Stack is being deleted - cleaning up S3 object")
                              s3.delete_object(Bucket=bucket_name, Key='openapi.yaml')
                              print("Successfully deleted openapi.yaml from S3")
                          else:
                              print("Resource replacement during stack update - preserving S3 object")

                      except Exception as check_error:
                          print(f"Could not determine stack status (preserving S3 object): {str(check_error)}")
                          # If we can't determine the stack status, err on the side of caution and don't delete

                      # Use the same physical resource ID for consistency
                      physical_resource_id = f"openapi-upload-{bucket_name}"
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, physical_resource_id)
                      return

                  # For Create and Update operations, upload/update the file
                  print(f"Processing {event['RequestType']} request - uploading OpenAPI spec")

                  # Fetch OpenAPI spec from URL
                  if not openapi_spec_url:
                      raise ValueError("OpenApiSpecUrl parameter is required")

                  print(f"OpenAPI spec URL: {openapi_spec_url}")
                  print(f"URL scheme: {openapi_spec_url.split(':')[0]}")
                  print(f"Attempting to fetch from URL...")

                  yaml_content = fetch_openapi_spec(openapi_spec_url)

                  # Replace the server URL placeholder if it exists
                  yaml_content = yaml_content.replace('${API_GATEWAY_URL}', api_gateway_url)

                  print(f"Uploading YAML content to S3 bucket: {bucket_name}")
                  print(f"Content length: {len(yaml_content)} bytes")
                  print(f"S3 Key: openapi.yaml")

                  try:
                      s3.put_object(
                          Bucket=bucket_name,
                          Key='openapi.yaml',
                          Body=yaml_content,
                          ContentType='application/x-yaml'
                      )
                      print(f"Successfully uploaded to S3")
                  except Exception as s3_error:
                      print(f"S3 put_object failed: {type(s3_error).__name__}: {str(s3_error)}")
                      if hasattr(s3_error, 'response'):
                          print(f"S3 Error Response: {s3_error.response}")
                      raise

                  s3_location = f's3://{bucket_name}/openapi.yaml'
                  response_data = {
                      'S3Location': s3_location,
                      'BucketName': bucket_name,
                      'ObjectKey': 'openapi.yaml'
                  }

                  print(f"Successfully uploaded OpenAPI spec to: {s3_location}")

                  # Use a consistent physical resource ID to prevent unnecessary replacements
                  physical_resource_id = f"openapi-upload-{bucket_name}"
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data, physical_resource_id)

              except Exception as e:
                  error_message = f"Error in S3 upload: {str(e)}"
                  print(error_message)

                  # Always send a response to prevent CloudFormation from hanging
                  try:
                      cfnresponse.send(event, context, cfnresponse.FAILED, {
                          'Error': error_message
                      })
                  except Exception as send_error:
                      print(f"Failed to send error response: {str(send_error)}")
                      # Last resort - try to send minimal response
                      try:
                          cfnresponse.send(event, context, cfnresponse.FAILED, {})
                      except:
                          print("Complete failure to send any response to CloudFormation")
    DeletionPolicy: Delete

  # Custom Resource to Upload OpenAPI Spec
  OpenApiUpload:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt S3UploadFunction.Arn
      BucketName: !Ref OpenApiBucket
      OpenApiSpecUrl: !Ref OpenApiSpecUrl
      ApiGatewayUrl: !Sub 'https://${TurnosApi}.execute-api.${AWS::Region}.amazonaws.com/dev'
    DependsOn: OpenApiBucket

  # Lambda Functions
  SearchMedicosFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs22.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref LambdaLogGroup
        LogFormat: JSON
      Environment:
        Variables:
          MEDICOS_TABLE_NAME: !Ref MedicosTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, QueryCommand } = require('@aws-sdk/lib-dynamodb');

          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);

          exports.handler = async (event) => {
              const requestId = event.requestContext?.requestId || 'unknown';
              console.log(JSON.stringify({
                  level: 'INFO',
                  message: 'Buscar medicos request received',
                  requestId,
                  event: event
              }));

              try {
                  const body = JSON.parse(event.body || '{}');
                  const { especialidad, ciudad, obraSocial } = body;

                  if (!especialidad) {
                      console.log(JSON.stringify({
                          level: 'WARN',
                          message: 'Missing required parameter: especialidad',
                          requestId
                      }));
                      return {
                          statusCode: 400,
                          headers: {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                          },
                          body: JSON.stringify({
                              error: 'Missing required parameter: especialidad',
                          }),
                      };
                  }

                  const params = {
                      TableName: process.env.MEDICOS_TABLE_NAME,
                      IndexName: 'EspecialidadIndex',
                      KeyConditionExpression: '#especialidad = :especialidad',
                      ExpressionAttributeNames: { '#especialidad': 'especialidad' },
                      ExpressionAttributeValues: { ':especialidad': especialidad }
                  };

                  // Agregar filtros opcionales
                  if (ciudad) {
                      params.FilterExpression = 'contains(#ciudad, :ciudad)';
                      params.ExpressionAttributeNames['#ciudad'] = 'ciudad';
                      params.ExpressionAttributeValues[':ciudad'] = ciudad;
                  }

                  console.log(JSON.stringify({
                      level: 'INFO',
                      message: 'Querying DynamoDB',
                      requestId,
                      especialidad,
                      ciudad: ciudad || 'any'
                  }));

                  const result = await docClient.send(new QueryCommand(params));

                  const response = {
                      statusCode: 200,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                      },
                      body: JSON.stringify({
                          medicos: result.Items || [],
                          cantidad: result.Count || 0,
                      }),
                  };

                  console.log(JSON.stringify({
                      level: 'INFO',
                      message: 'Medicos found',
                      requestId,
                      especialidad,
                      ciudad: ciudad || 'any',
                      count: result.Count || 0
                  }));

                  return response;
              } catch (error) {
                  console.log(JSON.stringify({
                      level: 'ERROR',
                      message: 'Error searching medicos',
                      requestId,
                      error: error.message,
                      stack: error.stack
                  }));
                  return {
                      statusCode: 500,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                      },
                      body: JSON.stringify({
                          error: 'Internal server error',
                          message: error.message,
                      }),
                  };
              }
          };

  CreateTurnoFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs22.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref LambdaLogGroup
        LogFormat: JSON
      Environment:
        Variables:
          TURNOS_TABLE_NAME: !Ref TurnosTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, PutCommand } = require('@aws-sdk/lib-dynamodb');
          const { randomBytes } = require('crypto');

          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);

          // Generate a realistic reservation ID (e.g., TURNO-ABC123XY)
          function generateTurnoId() {
              const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
              let id = 'TURNO-';
              const bytes = randomBytes(6);
              for (let i = 0; i < 6; i++) {
                  id += chars[bytes[i] % chars.length];
              }
              return id;
          }

          exports.handler = async (event) => {
              const requestId = event.requestContext?.requestId || 'unknown';
              console.log(JSON.stringify({
                  level: 'INFO',
                  message: 'Crear turno request received',
                  requestId,
                  event: event
              }));

              try {
                  const body = JSON.parse(event.body);
                  
                  // Aceptar tanto nombres viejos como nuevos para compatibilidad
                  const medicoId = body.medicoId;
                  const pacienteId = body.pacienteId;
                  const fechaTurno = body.fechaTurno || body.fecha;  // Acepta ambos
                  const horaTurno = body.horaTurno || body.hora;      // Acepta ambos
                  const motivoConsulta = body.motivoConsulta;
                  const nombrePaciente = body.nombrePaciente;
                  const emailPaciente = body.emailPaciente;
                  const telefono = body.telefono || body.telefonoPaciente;  // Acepta ambos
                  const comentarios = body.comentarios;

                  console.log(JSON.stringify({
                      level: 'INFO',
                      message: 'Creando turno',
                      requestId,
                      medicoId,
                      pacienteId,
                      fechaTurno,
                      horaTurno,
                      motivoConsulta,
                      nombrePaciente
                  }));

                  if (!medicoId || !pacienteId || !fechaTurno || !horaTurno || !motivoConsulta || !nombrePaciente || !emailPaciente) {
                      const missingParams = [];
                      if (!medicoId) missingParams.push('medicoId');
                      if (!pacienteId) missingParams.push('pacienteId');
                      if (!fechaTurno) missingParams.push('fechaTurno');
                      if (!horaTurno) missingParams.push('horaTurno');
                      if (!motivoConsulta) missingParams.push('motivoConsulta');
                      if (!nombrePaciente) missingParams.push('nombrePaciente');
                      if (!emailPaciente) missingParams.push('emailPaciente');

                      console.log(JSON.stringify({
                          level: 'WARN',
                          message: 'Missing required parameters',
                          requestId,
                          missingParameters: missingParams,
                          medicoId,
                          pacienteId,
                          fechaTurno,
                          horaTurno,
                          motivoConsulta,
                          nombrePaciente,
                          emailPaciente
                      }));
                      return {
                          statusCode: 400,
                          headers: {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                          },
                          body: JSON.stringify({
                              error: `Missing required parameters: ${missingParams.join(', ')}`,
                          }),
                      };
                  }

                  const turnoId = generateTurnoId();
                  const reservation = {
                      turnoId,
                      medicoId,
                      pacienteId,
                      fechaTurno,
                      horaTurno,
                      motivoConsulta,
                      nombrePaciente,
                      emailPaciente,
                      telefono: telefono || 'No especificado',
                      estado: 'confirmado',
                      createdAt: new Date().toISOString(),
                      valorConsulta: calculateTotalAmount(motivoConsulta, fechaTurno, horaTurno),
                  };

                  // Add optional fields if provided
                  if (comentarios) {
                      reservation.comentarios = comentarios;
                  }

                  const params = {
                      TableName: process.env.TURNOS_TABLE_NAME,
                      Item: reservation,
                  };

                  await docClient.send(new PutCommand(params));

                  const response = {
                      statusCode: 201,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                      },
                      body: JSON.stringify({
                          message: 'Turno creado successfully',
                          reservation,
                      }),
                  };

                  console.log(JSON.stringify({
                      level: 'INFO',
                      message: 'Turno creado successfully',
                      requestId,
                      turnoId,
                      medicoId,
                      response: response
                  }));

                  return response;
              } catch (error) {
                  console.log(JSON.stringify({
                      level: 'ERROR',
                      message: 'Error creating reservation',
                      requestId,
                      error: error.message,
                      stack: error.stack
                  }));
                  return {
                      statusCode: 500,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                      },
                      body: JSON.stringify({
                          error: 'Internal server error',
                          message: error.message,
                      }),
                  };
              }
          };

          function calculateTotalAmount(motivoConsulta, fechaTurno, horaTurno) {
              // Valores de consulta por defecto
              const valoresConsulta = {
                  'Control': 8000,
                  'Urgencia': 12000,
                  'Primera consulta': 10000,
                  'Control rutinario': 8000,
                  'Seguimiento': 8000,
              };

              // Retornar valor segÃºn motivo o valor por defecto
              return valoresConsulta[motivoConsulta] || 10000;
          }

  GetTurnosPacienteFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref LambdaLogGroup
        LogFormat: JSON
      Environment:
        Variables:
          TURNOS_TABLE_NAME: !Ref TurnosTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import traceback
          from decimal import Decimal

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TURNOS_TABLE_NAME'])

          # Helper function to convert Decimal to int/float for JSON serialization
          def decimal_default(obj):
              if isinstance(obj, Decimal):
                  return int(obj) if obj % 1 == 0 else float(obj)
              raise TypeError

          def handler(event, context):
              request_id = event.get('requestContext', {}).get('requestId', 'unknown')
              print(json.dumps({
                  'level': 'INFO',
                  'message': 'Obtener turnos de paciente request received',
                  'requestId': request_id,
                  'event': event
              }))

              try:
                  # Handle both API Gateway and direct invocation
                  if 'body' in event and event['body']:
                      body = json.loads(event['body'])
                      customer_id = body.get('pacienteId')
                  else:
                      # Direct invocation from Connect Assistant
                      customer_id = event.get('pacienteId')

                  print(json.dumps({
                      'level': 'INFO',
                      'message': 'Fetching reservations for customer',
                      'requestId': request_id,
                      'pacienteId': customer_id
                  }))

                  if not customer_id:
                      print(json.dumps({
                          'level': 'WARN',
                          'message': 'Missing pacienteId parameter',
                          'requestId': request_id
                      }))
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'pacienteId parameter is required'})
                      }

                  response = table.query(
                      IndexName='PacienteIndex',
                      KeyConditionExpression='pacienteId = :pacienteId',
                      ExpressionAttributeValues={':pacienteId': customer_id}
                  )

                  turnos = response['Items']
                  result = {
                      'statusCode': 200,
                      'body': json.dumps({
                          'turnos': turnos,
                          'cantidad': len(turnos),
                          'pacienteId': customer_id
                      }, default=decimal_default)
                  }

                  print(json.dumps({
                      'level': 'INFO',
                      'message': 'Turnos found',
                      'requestId': request_id,
                      'pacienteId': customer_id,
                      'cantidad': len(turnos)
                  }))

                  return result
              except Exception as e:
                  print(json.dumps({
                      'level': 'ERROR',
                      'message': 'Error getting customer reservations',
                      'requestId': request_id,
                      'error': str(e),
                      'stack': traceback.format_exc()
                  }))
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)}, default=decimal_default)
                  }

  CancelTurnoFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs22.x
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref LambdaLogGroup
        LogFormat: JSON
      Environment:
        Variables:
          TURNOS_TABLE_NAME: !Ref TurnosTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
          const { DynamoDBDocumentClient, GetCommand, UpdateCommand } = require('@aws-sdk/lib-dynamodb');

          const client = new DynamoDBClient({});
          const docClient = DynamoDBDocumentClient.from(client);

          exports.handler = async (event) => {
              const requestId = event.requestContext?.requestId || 'unknown';
              console.log(JSON.stringify({
                  level: 'INFO',
                  message: 'Cancelar turno request received',
                  requestId,
                  event: event
              }));

              try {
                  const body = JSON.parse(event.body);
                  const { turnoId } = body;

                  if (!turnoId) {
                      console.log(JSON.stringify({
                          level: 'WARN',
                          message: 'Missing turnoId parameter',
                          requestId
                      }));
                      return {
                          statusCode: 400,
                          headers: {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                          },
                          body: JSON.stringify({
                              error: 'Missing turnoId parameter',
                          }),
                      };
                  }

                  console.log(JSON.stringify({
                      level: 'INFO',
                      message: 'Cancelling reservation',
                      requestId,
                      turnoId
                  }));

                  // First check if reservation exists
                  const getParams = {
                      TableName: process.env.TURNOS_TABLE_NAME,
                      Key: { turnoId },
                  };

                  const getResult = await docClient.send(new GetCommand(getParams));

                  if (!getResult.Item) {
                      console.log(JSON.stringify({
                          level: 'WARN',
                          message: 'Reservation not found',
                          requestId,
                          turnoId
                      }));
                      return {
                          statusCode: 404,
                          headers: {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                          },
                          body: JSON.stringify({
                              error: 'Reservation not found',
                          }),
                      };
                  }

                  if (getResult.Item.status === 'cancelled') {
                      console.log(JSON.stringify({
                          level: 'WARN',
                          message: 'Reservation already cancelled',
                          requestId,
                          turnoId
                      }));
                      return {
                          statusCode: 400,
                          headers: {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*',
                          },
                          body: JSON.stringify({
                              error: 'Reservation is already cancelled',
                          }),
                      };
                  }

                  // Update reservation status to cancelled
                  const updateParams = {
                      TableName: process.env.TURNOS_TABLE_NAME,
                      Key: { turnoId },
                      UpdateExpression: 'SET #status = :status, cancelledAt = :cancelledAt',
                      ExpressionAttributeNames: { '#status': 'status' },
                      ExpressionAttributeValues: {
                          ':status': 'cancelled',
                          ':cancelledAt': new Date().toISOString(),
                      },
                      ReturnValues: 'ALL_NEW',
                  };

                  const updateResult = await docClient.send(new UpdateCommand(updateParams));

                  const response = {
                      statusCode: 200,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                      },
                      body: JSON.stringify({
                          message: 'Reservation cancelled successfully',
                          turno: updateResult.Attributes,
                      }),
                  };

                  console.log(JSON.stringify({
                      level: 'INFO',
                      message: 'Reservation cancelled successfully',
                      requestId,
                      turnoId,
                      response: response
                  }));

                  return response;
              } catch (error) {
                  console.log(JSON.stringify({
                      level: 'ERROR',
                      message: 'Error cancelling reservation',
                      requestId,
                      error: error.message,
                      stack: error.stack
                  }));
                  return {
                      statusCode: 500,
                      headers: {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*',
                      },
                      body: JSON.stringify({
                          error: 'Internal server error',
                          message: error.message,
                      }),
                  };
              }
          };

  ModifyTurnoFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref LambdaLogGroup
        LogFormat: JSON
      Environment:
        Variables:
          TURNOS_TABLE_NAME: !Ref TurnosTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import traceback
          from datetime import datetime
          from decimal import Decimal

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TURNOS_TABLE_NAME'])

          # Helper function to convert Decimal to int/float for JSON serialization
          def decimal_default(obj):
              if isinstance(obj, Decimal):
                  return int(obj) if obj % 1 == 0 else float(obj)
              raise TypeError

          def handler(event, context):
              request_id = event.get('requestContext', {}).get('requestId', 'unknown')
              print(json.dumps({
                  'level': 'INFO',
                  'message': 'Modificar turno request received',
                  'requestId': request_id,
                  'event': event
              }))

              try:
                  # Handle both API Gateway and direct invocation
                  if 'body' in event and event['body']:
                      body = json.loads(event['body'])
                  else:
                      # Direct invocation from Connect Assistant
                      body = event

                  reservation_id = body.get('turnoId')
                  customer_id = body.get('pacienteId')

                  print(json.dumps({
                      'level': 'INFO',
                      'message': 'Modifying reservation',
                      'requestId': request_id,
                      'turnoId': reservation_id,
                      'pacienteId': customer_id
                  }))

                  if not reservation_id or not customer_id:
                      missing_params = []
                      if not reservation_id:
                          missing_params.append('turnoId')
                      if not customer_id:
                          missing_params.append('pacienteId')

                      print(json.dumps({
                          'level': 'WARN',
                          'message': 'Missing required parameters',
                          'requestId': request_id,
                          'missingParameters': missing_params,
                          'turnoId': reservation_id,
                          'pacienteId': customer_id
                      }))
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': f'Missing required parameters: {", ".join(missing_params)}'})
                      }

                  # Build update expression dynamically
                  update_expression = 'SET modifiedAt = :modifiedAt'
                  expression_values = {':modifiedAt': datetime.utcnow().isoformat()}

                  # Add fields to update - acepta ambos nombres (fecha/fechaTurno, hora/horaTurno)
                  if 'fechaTurno' in body or 'fecha' in body:
                      fecha = body.get('fechaTurno') or body.get('fecha')
                      update_expression += ', fechaTurno = :fechaTurno'
                      expression_values[':fechaTurno'] = fecha

                  if 'horaTurno' in body or 'hora' in body:
                      hora = body.get('horaTurno') or body.get('hora')
                      update_expression += ', horaTurno = :horaTurno'
                      expression_values[':horaTurno'] = hora

                  if 'motivoConsulta' in body:
                      update_expression += ', motivoConsulta = :motivoConsulta'
                      expression_values[':motivoConsulta'] = body['motivoConsulta']
                  
                  if 'telefono' in body or 'telefonoPaciente' in body:
                      telefono = body.get('telefono') or body.get('telefonoPaciente')
                      update_expression += ', telefono = :telefono'
                      expression_values[':telefono'] = telefono

                  response = table.update_item(
                      Key={'turnoId': reservation_id},
                      UpdateExpression=update_expression,
                      ConditionExpression='pacienteId = :pacienteId',
                      ExpressionAttributeValues={
                          **expression_values,
                          ':pacienteId': customer_id
                      },
                      ReturnValues='ALL_NEW'
                  )

                  result = {
                      'statusCode': 200,
                      'body': json.dumps({
                          'success': True,
                          'message': 'Reservation modified successfully',
                          'reservation': response['Attributes']
                      }, default=decimal_default)
                  }

                  print(json.dumps({
                      'level': 'INFO',
                      'message': 'Reservation modified successfully',
                      'requestId': request_id,
                      'turnoId': reservation_id,
                      'response': result
                  }))

                  return result
              except Exception as e:
                  print(json.dumps({
                      'level': 'ERROR',
                      'message': 'Error modifying reservation',
                      'requestId': request_id,
                      'error': str(e),
                      'stack': traceback.format_exc()
                  }))
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e), 'success': False}, default=decimal_default)
                  }

  # Lambda Permissions
  SearchMedicosPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SearchMedicosFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TurnosApi}/*/*'

  CreateTurnoPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CreateTurnoFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TurnosApi}/*/*'

  CancelTurnoPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CancelTurnoFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TurnosApi}/*/*'

  GetTurnosPacientePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetTurnosPacienteFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TurnosApi}/*/*'

  ModifyTurnoPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ModifyTurnoFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TurnosApi}/*/*'

  TurnosApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: ClinicaSalud Turnos API
      Description: API para gestion de turnos medicos
      Body:
        openapi: '3.0.1'
        info:
          title: 'ClinicaSalud Turnos API'
          version: '1.0.0'
        paths:
          /medicos/buscar:
            post:
              x-amazon-apigateway-integration:
                type: 'aws_proxy'
                httpMethod: 'POST'
                uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SearchMedicosFunction.Arn}/invocations'
          /turnos:
            post:
              x-amazon-apigateway-integration:
                type: 'aws_proxy'
                httpMethod: 'POST'
                uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateTurnoFunction.Arn}/invocations'
          /turnos/paciente:
            post:
              x-amazon-apigateway-integration:
                type: 'aws_proxy'
                httpMethod: 'POST'
                uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetTurnosPacienteFunction.Arn}/invocations'
          /turnos/modificar:
            post:
              x-amazon-apigateway-integration:
                type: 'aws_proxy'
                httpMethod: 'POST'
                uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ModifyTurnoFunction.Arn}/invocations'
          /turnos/cancelar:
            post:
              x-amazon-apigateway-integration:
                type: 'aws_proxy'
                httpMethod: 'POST'
                uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CancelTurnoFunction.Arn}/invocations'
        components:
          securitySchemes:
            api_key:
              type: 'apiKey'
              name: 'X-API-Key'
              in: 'header'

  # API Key for authentication
  TurnosApiKey:
    Type: AWS::ApiGateway::ApiKey
    Properties:
      Name: !Sub '${AWS::StackName}-turnos-api-key'
      Description: API Key for Turnos Medicos API
      Enabled: true
      GenerateDistinctId: true

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: ApiGatewayAccount
    Properties:
      RestApiId: !Ref TurnosApi

  ApiStageDev:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref TurnosApi
      DeploymentId: !Ref ApiDeployment
      StageName: dev
      TracingEnabled: true
      AccessLogSetting:
        DestinationArn: !GetAtt ApiLogGroup.Arn
        Format:
          '$context.requestId $context.requestTime $context.httpMethod
          $context.resourcePath $context.status $context.responseLength'
      MethodSettings:
        - ResourcePath: '/*'
          HttpMethod: '*'
          LoggingLevel: INFO
          DataTraceEnabled: true
          MetricsEnabled: true

Outputs:
  TurnosApiUrl:
    Description: URL of the Hotel API
    Value: !Sub 'https://${TurnosApi}.execute-api.${AWS::Region}.amazonaws.com/dev'

  ApiKey:
    Description: Value of the API Key
    Value: !GetAtt ApiKeyValueRetrieval.ApiKeyValue

  MedicosTableName:
    Description: Name of the DynamoDB Hotels table
    Value: !Ref MedicosTable

  OpenApiSpecS3Location:
    Description: S3 location of the uploaded OpenAPI specification
    Value: !GetAtt OpenApiUpload.S3Location
